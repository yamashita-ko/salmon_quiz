<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>サモランクイズ</title>
    <link href="images/weapon/spshu.png" rel="icon">
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      canvas {
        background: #eee;
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="1920" height="1080"></canvas>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.1.2/sprintf.min.js"></script>
	<script src="js/calc.js"></script>
	<script src="js/const.js"></script>
	<script src="js/mode_select.js"></script>
	<script src="js/weapon_quiz.js"></script>
	<script src="js/weapon_quiz_result.js"></script>
	<script src="js/normal_quiz.js"></script>
	<script>
		var CANVAS_MARGIN_TOP = 100;
		var canvas = document.getElementById("canvas");
		var ctx = canvas.getContext("2d");
		var objCols = [];
		var mode;
		
		/**
		 * 初回起動
		 */
		window.onload = () => {
		    var func = () => {
				changeMode(MODE.SELECT);
			}
		    initDraw(func);
		}
		
		/**
		 * キャンバス内クリック判定処理
		 * @param {Object} event DOMイベント
		 */
		window.canvas.onclick = (event) => {
    		const rect = event.target.getBoundingClientRect();
    		let mouse = {x: event.clientX - rect.left, y: event.clientY - rect.top};
			console.log("X:" + mouse.x + " Y:" + mouse.y);
            for (let i = 0; i < window.objCols.length; i++) {
				if((window.objCols[i].state & TEXT_STATE.IS_BUTTON) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ENABLE) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ACTIVE) == false) continue;
				if(collision(window.objCols[i].centerX, window.objCols[i].centerY, window.objCols[i].scaleX, window.objCols[i].scaleY, mouse.x, mouse.y) == false) {
					continue;
				}
				if(window.mode == MODE.SELECT){
					clickModeSelect(window.objCols[i]);
				} else if(window.mode == MODE.WEAPON_QUIZ) {
					clickWeaponQuiz(window.objCols[i]);
				} else if(window.mode == MODE.WEAPON_QUIZ_RESULT) {
					clickWeaponQuizResult(window.objCols[i]);
				} else if(window.mode == MODE.NORMAL_QUIZ) {
					clickNormalQuiz(window.objCols[i]);
				}
				break;
			}
		}
		
		/**
		 * 背景描画→関数オブジェクト描画
		 * @param {function} func 背景描画後の処理
		 */
		function initDraw(func) {
			// 背景画像の読み込み後に処理を行う 読み込み前に処理を行うと画面崩れする
			var background = new Image();
			background.src = "http://" + location.host + "/images/bg.png";
		    background.onload = function() {
				window.ctx.drawImage(background, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
				func();
			}
		}
		
		/**
		 * モード変更
		 * @param {Object} mode 背景描画後の処理
		 */
		function changeMode(mode) {
			clear(window.ctx, CANVAS_WIDTH, CANVAS_HEIGHT);
			window.objCols = [];
			window.mode = mode;
			var func = {};
			var result = [];
			
			if(mode == MODE.SELECT) {
				func = createModeSelect;
			} else if(mode == MODE.WEAPON_QUIZ) {
				func = createWeaponQuiz;
			} else if(mode == MODE.WEAPON_QUIZ_RESULT) {
				func = createWeaponQuizResult;
			} else if(mode == MODE.NORMAL_QUIZ) {
				func = () => {
					createNormalQuiz();
				}
			}
	        initDraw(func);
		}
		
		/**
		 * マウスホバー処理
		 * @param {Object} event DOMイベント
		 */
		canvas.onmousemove = (event) => {
    		const rect = event.target.getBoundingClientRect();
    		let mouse = {x: event.clientX - rect.left, y: event.clientY - rect.top};
			
            for (let i = 0; i < window.objCols.length; i++) {
				if((window.objCols[i].state & TEXT_STATE.IS_BUTTON) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ENABLE) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ACTIVE) == false) continue;
				if(collision(window.objCols[i].centerX, window.objCols[i].centerY, window.objCols[i].scaleX, window.objCols[i].scaleY, mouse.x, mouse.y) == false) {
					if(window.objCols[i].state & TEXT_STATE.HOVER) {
						// ボタン消灯
						window.objCols[i].state &= ~TEXT_STATE.HOVER;
						drawText(window.objCols[i]);
					}
					continue;
				}
				if(window.objCols[i].state & TEXT_STATE.HOVER){
					continue;
				}
        		// ボタン点灯
				window.objCols[i].state |= TEXT_STATE.HOVER;
				drawText(window.objCols[i]);
			}
		}
		
		/**
		 * 画面削除処理
		 * @param {Object} ctx キャンバスのContext
		 * @param {number} width 幅
		 * @param {number} height 高さ
		 */
		function clear(ctx, width, height) {
			ctx.clearRect(0, 0, width, height);
		}
		
		/**
		 * 判定用オブジェクト作成
		 * @param {Object} data 元データ
		 * @return {Object} 判定用オブジェクト
		 */
		function createObject(data) {
			var obj = {};
			obj.name = data.NAME;
			obj.text = data.TEXT;
			obj.fontSize = data.FONT_SIZE;
			obj.centerX = data.CENTERX;
			obj.centerY = data.CENTERY;
			obj.scaleX = data.SCALEX;
			obj.scaleY = data.SCALEY;
			obj.textColor = data.TEXT_COLOR;
			obj.bgColor = data.BG_COLOR;
			obj.state = data.STATE;
			obj.image = data.IMAGE;
			obj.hoverImage = data.HOVER_IMAGE;
			obj.disableImage = data.DISABLE_IMAGE;
			obj.hilightImage = data.HILIGHT_IMAGE;
			obj.group = data.GROUP;
			return obj;
		}
		
		/**
		 * オブジェクト描画
		 * @param {Object} obj 判定用オブジェクト
		 * @return {Object} 判定用オブジェクト
		 */
		function drawText(obj) {
			if((obj.state & TEXT_STATE.ENABLE) == false)
				return obj
			ctxDrawBG(obj);
			var func = () => {
				ctxDrawText(obj);
			};
 			if(obj.state & TEXT_STATE.IMAGE) {
				ctxDrawImage(obj, func);
			} else {
				func();
			}
			
			return obj;
		}
		
		function ctxDrawImage(obj, func) {
 			if(obj.state & TEXT_STATE.IMAGE) {
				const chara = new Image();
				if(obj.state & TEXT_STATE.HILIGHT && obj.hilightImage) {
					chara.src = obj.hilightImage;
				} else if((obj.state & TEXT_STATE.ACTIVE) == false && obj.disableImage) {
					chara.src = obj.disableImage;
				} else if(obj.state & TEXT_STATE.HOVER && obj.hoverImage) {
					chara.src = obj.hoverImage;
				} else {
					chara.src = obj.image;
				}
				chara.onload = () => {
					let imgStartX = obj.centerX - obj.scaleX / 2;
					let imgStartY = obj.centerY - obj.scaleY / 2;
					let imgScaleX = obj.scaleX;
					let imgScaleY = obj.scaleY;
 					if(obj.state & TEXT_STATE.ADJUST_ASPECT) {
						if(chara.naturalWidth / chara.naturalHeight < imgScaleX / imgScaleY) {
							// Y軸を最大にしてX軸を減らす
							let oldScaleX = imgScaleX;
							imgScaleX = chara.naturalWidth * (imgScaleY / chara.naturalHeight);
							imgStartX = imgStartX + (oldScaleX - imgScaleX) / 2;
						} else {
							// X軸を最大にしてY軸を減らす
							let oldScaleY = imgScaleY;
							imgScaleY = chara.naturalHeight * (imgScaleX / chara.naturalWidth);
							imgStartY = imgStartY + (oldScaleY - imgScaleY) / 2;
						}
					}
					const PADDING = 10;
					if(obj.state & TEXT_STATE.IMAGE_CENTERX) {
						imgStartX += PADDING;
						imgScaleX -= PADDING * 2;
					}
					if(obj.state & TEXT_STATE.IMAGE_CENTERY) {
						imgStartY += PADDING;
						imgScaleY -= PADDING * 2;
					}
					window.ctx.drawImage(chara, imgStartX, imgStartY, imgScaleX, imgScaleY);
					func();
				}
			}
		}
		function ctxDrawBG(obj) {
			if((obj.state & TEXT_STATE.BG_DISABLE) == false) {
	 			// テキスト背景描画
				window.ctx.beginPath();
				if(obj.state & TEXT_STATE.BG_KADOMARU) {
					createRoundRectPath(window.ctx, obj.centerX - obj.scaleX / 2, obj.centerY - obj.scaleY / 2, obj.scaleX, obj.scaleY, 20)
				} else {
					window.ctx.rect(obj.centerX - obj.scaleX / 2, obj.centerY - obj.scaleY / 2, obj.scaleX, obj.scaleY)
				}
				if(typeof obj.bgColor === 'object') {
					let bgColor = obj.state & TEXT_STATE.HOVER ? obj.bgColor.HOVER : obj.bgColor.NORMAL;
					bgColor = obj.state & TEXT_STATE.ACTIVE ? bgColor : obj.bgColor.DISABLE;
					bgColor = obj.state & TEXT_STATE.HILIGHT ? obj.bgColor.HILIGHT: bgColor;
					window.ctx.fillStyle = bgColor;
				} else {
					window.ctx.fillStyle = obj.bgColor;
				}
				window.ctx.fill();
				// エッジ描画
				window.ctx.strokeStyle = "rgba(0, 0, 255, 0.5)";
				window.ctx.stroke();
				window.ctx.closePath();
			}
		}
		function ctxDrawText(obj) {
			const TEXT_MARGIN = 20;
			// \nを区切り文字として分割
 			if(obj.state & TEXT_STATE.IS_TEXT) {
		  		window.ctx.font = "bold " + obj.fontSize + "px Arial";
				const measure = window.ctx.measureText(obj.text);
				const textHeight= measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent;
				const texts = obj.text.split("\\n");
				for(let i = 0; i < texts.length; i++) {
		 			var textPosX = obj.centerX - obj.scaleX / 2 + TEXT_MARGIN;
		 			var textPosY = obj.centerY - obj.scaleY / 2 + textHeight + TEXT_MARGIN;
		 			if(obj.state & TEXT_STATE.CENTERX) {
						let textWidth = window.ctx.measureText(texts[i]).width;
		 				textPosX = obj.centerX - textWidth / 2;
		 			}
		 			if(obj.state & TEXT_STATE.CENTERY) {
		 				//textPosY = obj.centerY + textHeight / 2;
		 				textPosY = obj.centerY - (textHeight) * texts.length / 2 + (textHeight) * (i + 1);
		 			} else {
		 				textPosY += (textHeight + TEXT_MARGIN) * i;
					 }
					window.ctx.fillStyle = obj.textColor;
					window.ctx.fillText(texts[i], textPosX, textPosY);
					//window.ctx.strokeStyle = '#000000';
					//window.ctx.lineWidth = 1.5;
					//window.ctx.strokeText(texts[i], textPosX, textPosY);
				}
			}
		}
    </script>
  </body>
</html>