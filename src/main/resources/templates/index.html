<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>サモランクイズ</title>
    <link href="images/weapon/spshu.png" rel="icon">
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      canvas {
        background: #eee;
        display: block;
        margin: 0 auto;
      }
      @font-face {
        font-family: 'ikamodoki1_0';   /* フォント名 */
        src: url('font/ikamodoki1_0.ttf') format('truetype');   /* フォントファイル */
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="1920" height="1080"></canvas>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.1.2/sprintf.min.js"></script>
	<script src="js/calc.js"></script>
	<script src="js/const.js"></script>
	<script src="js/mode_select.js"></script>
	<script src="js/weapon_quiz.js"></script>
	<script src="js/weapon_quiz_result.js"></script>
	<script src="js/normal_quiz.js"></script>
	<script>
		var CANVAS_MARGIN_TOP = 100;
		var canvas = document.getElementById("canvas");
		var ctx = canvas.getContext("2d");
		var objCols = [];
		var mode;
		var updateImages = [];
		var background;
		
		/**
		 * 初回起動
		 */
		window.onload = () => {
			var fonts = document.fonts;
			var p = fonts.load('10px ' + FONT_IKA);
			p.then(() => {
				changeMode(MODE.SELECT);
			});
		    
		}
		
		/**
		 * キャンバス内クリック判定処理
		 * @param {Object} event DOMイベント
		 */
		window.canvas.onclick = (event) => {
    		const rect = event.target.getBoundingClientRect();
    		let mouse = {x: event.clientX - rect.left, y: event.clientY - rect.top};
			console.log("X:" + mouse.x + " Y:" + mouse.y);
            for (let i = 0; i < window.objCols.length; i++) {
				if((window.objCols[i].state & TEXT_STATE.IS_BUTTON) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ENABLE) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ACTIVE) == false) continue;
				if(collision(window.objCols[i].centerX, window.objCols[i].centerY, window.objCols[i].scaleX, window.objCols[i].scaleY, mouse.x, mouse.y) == false) {
					continue;
				}
				if(window.mode == MODE.SELECT){
					clickModeSelect(window.objCols[i]);
				} else if(window.mode == MODE.WEAPON_QUIZ) {
					clickWeaponQuiz(window.objCols[i]);
				} else if(window.mode == MODE.WEAPON_QUIZ_RESULT) {
					clickWeaponQuizResult(window.objCols[i]);
				} else if(window.mode == MODE.NORMAL_QUIZ) {
					clickNormalQuiz(window.objCols[i]);
				}
				break;
			}
		}
		
		/**
		 * 背景描画→関数オブジェクト描画
		 * @param {function} func 背景描画後の処理
		 */
		function initDraw(func) {
			// 背景画像の読み込み後に処理を行う 読み込み前に処理を行うと画面崩れする
			var background = new Image();
			background.src = "http://" + location.host + "/images/bg.png";
		    background.onload = function() {
				window.ctx.drawImage(background, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
				func();
			}
		}
		
		/**
		 * モード変更
		 * @param {Object} mode 背景描画後の処理
		 */
		function changeMode(mode) {
			clear(window.ctx, CANVAS_WIDTH, CANVAS_HEIGHT);
			window.objCols = [];
			window.mode = mode;
			var func = {};
			var result = [];
			
			if(mode == MODE.SELECT) {
				func = createModeSelect;
			} else if(mode == MODE.WEAPON_QUIZ) {
				func = createWeaponQuiz;
			} else if(mode == MODE.WEAPON_QUIZ_RESULT) {
				func = createWeaponQuizResult;
			} else if(mode == MODE.NORMAL_QUIZ) {
				func = () => {
					createNormalQuiz();
				}
			}
	        func();
		}
		
		/**
		 * マウスホバー処理
		 * @param {Object} event DOMイベント
		 */
		canvas.onmousemove = (event) => {
    		const rect = event.target.getBoundingClientRect();
    		let mouse = {x: event.clientX - rect.left, y: event.clientY - rect.top};
			
            for (let i = 0; i < window.objCols.length; i++) {
				if((window.objCols[i].state & TEXT_STATE.IS_BUTTON) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ENABLE) == false) continue;
				if((window.objCols[i].state & TEXT_STATE.ACTIVE) == false) continue;
				if(collision(window.objCols[i].centerX, window.objCols[i].centerY, window.objCols[i].scaleX, window.objCols[i].scaleY, mouse.x, mouse.y) == false) {
					if(window.objCols[i].state & TEXT_STATE.HOVER) {
						// ボタン消灯
						window.objCols[i].state &= ~TEXT_STATE.HOVER;
						drawAll();
					}
					continue;
				}
				weaponQuizHoverAction(window.objCols[i]);
				if(window.objCols[i].state & TEXT_STATE.HOVER){
					continue;
				}
        		// ボタン点灯
				window.objCols[i].state |= TEXT_STATE.HOVER;
				drawAll();
			}
		}
		
		/**
		 * 画面削除処理
		 * @param {Object} ctx キャンバスのContext
		 * @param {number} width 幅
		 * @param {number} height 高さ
		 */
		function clear(ctx, width, height) {
			ctx.clearRect(0, 0, width, height);
		}
		
		/**
		 * 判定用オブジェクト作成
		 * @param {Object} data 元データ
		 * @return {Object} 判定用オブジェクト
		 */
		function createObject(data) {
			var obj = {};
			const DEFAULT_KADOMARU_SIZE = 20;
			obj.name = data.NAME;
			obj.text = data.TEXT;
			obj.fontSize = data.FONT_SIZE;
			obj.centerX = data.CENTERX;
			obj.centerY = data.CENTERY;
			obj.scaleX = data.SCALEX;
			obj.scaleY = data.SCALEY;
			obj.textColor = data.TEXT_COLOR;
			obj.bgColor = data.BG_COLOR;
			obj.state = data.STATE;
			obj.defaultState = data.STATE;
			obj.imagePath = data.IMAGE;
			obj.hoverImagePath = data.HOVER_IMAGE;
			obj.disableImagePath = data.DISABLE_IMAGE;
			obj.hilightImagePath = data.HILIGHT_IMAGE;
			obj.image = createImage(data.IMAGE);
			if(data.IMAGE_OBJ)
				obj.image = data.IMAGE_OBJ;
			obj.hoverImage = createImage(data.HOVER_IMAGE);
			obj.disableImage = createImage(data.DISABLE_IMAGE);
			obj.hilightImage = createImage(data.HILIGHT_IMAGE);
			obj.group = data.GROUP;
			obj.font = data.FONT ? data.FONT : FONT_DEFAULT;
			obj.margin = data.MARGIN;
			obj.lineHeight = data.LINE_HEIGHT;
			if(obj.state & TEXT_STATE.BG_KADOMARU) {
				obj.kadomaruSize = data.KADOMARU_SIZE ? data.KADOMARU_SIZE : DEFAULT_KADOMARU_SIZE;
			}
			return obj;
		}
		
		/**
		 * objColsをすべて描画
		 */
		function drawAll() {
			let func = () => { 
				window.objCols.map((o) => {
					drawText(o);
				});
			}
			ckeckLoadImageExecFunc(func);
		}
		
		/**
		 * objColsのstateをすべてリセット
		 */
		function resetState() {
			window.objCols.map((o) => {
				o.state = o.defaultState;
			});
		}
		
		/**
		 * Imageオブジェクト生成
		 * @param {String} path パス
		 * @return {Object} Imageオブジェクト
		 */
		function createImage(path) {
			if(!path) return;
			if(path == IGNORE_LOAD_PATH) return;
			const image = new Image();
			image.src = path;
			window.updateImages.push(image);
			return image;
		}
		
		/**
		 * Load完了チェック後にFunction実施
		 * @param {Function} func 関数
		 */
		function ckeckLoadImageExecFunc(func) {
			if(window.updateImages.length == 0) func();
			let loadCount = 0;
			let loadFunc = () => {
				loadCount++;
				if(loadCount == window.updateImages.length) {
					func();
					window.updateImages = [];
				}
			}
			for(let i = 0; i < window.updateImages.length; i++) {
				window.updateImages[i].onload = loadFunc;
				window.updateImages[i].onerror = loadFunc;
			}
		}
		
		/**
		 * オブジェクト描画
		 * @param {Object} obj 判定用オブジェクト
		 * @return {Object} 判定用オブジェクト
		 */
		function drawText(obj) {
			if((obj.state & TEXT_STATE.ENABLE) == false)
				return obj
			ctxDrawBG(obj);
			var func = () => {
				ctxDrawText(obj);
			};
 			if(obj.state & TEXT_STATE.IMAGE) {
				ctxDrawImage(obj, func);
			} else {
				func();
			}
			return obj;
		}
		
		/**
		 * オブジェクトのグループをフィルタリングした後に関数実行
		 * @param {String} group グループ名
		 * @param {Function} func 関数(第一引数にオブジェクトを選択させること)
		 */
		function filterGroupExecFunc(group, func) {
			let objs = window.objCols.filter((o) => o.group == group);
			objs.map((o) => {
				func(o);
			})
		}
		
		/**
		 * オブジェクトの名前を検索した後に関数実行
		 * @param {String} group グループ名
		 * @param {Function} func 関数(第一引数にオブジェクトを選択させること)
		 */
		function findNameExecFunc(name, func) {
			let obj = window.objCols.find((o) => o.name == name);
			func(obj);
		}
		
		function ctxDrawImage(obj, func) {
			// 画像がケースケア
 			if(obj.state & TEXT_STATE.IMAGE) {
				let chara;
				if(obj.state & TEXT_STATE.HILIGHT && obj.hilightImage) {
					chara = obj.hilightImage;
				} else if((obj.state & TEXT_STATE.ACTIVE) == false && obj.disableImage) {
					chara = obj.disableImage;
				} else if(obj.state & TEXT_STATE.HOVER && obj.hoverImage) {
					chara = obj.hoverImage;
				} else {
					chara = obj.image;
				}
				if(!chara) return;
				if(chara.width == 0) return;
				let imgStartX = obj.centerX - obj.scaleX / 2;
				let imgStartY = obj.centerY - obj.scaleY / 2;
				let imgScaleX = obj.scaleX;
				let imgScaleY = obj.scaleY;
				if(obj.state & TEXT_STATE.ADJUST_ASPECT) {
					if(chara.naturalWidth / chara.naturalHeight < imgScaleX / imgScaleY) {
						// Y軸を最大にしてX軸を減らす
						let oldScaleX = imgScaleX;
						imgScaleX = chara.naturalWidth * (imgScaleY / chara.naturalHeight);
						imgStartX = imgStartX + (oldScaleX - imgScaleX) / 2;
					} else {
						// X軸を最大にしてY軸を減らす
						let oldScaleY = imgScaleY;
						imgScaleY = chara.naturalHeight * (imgScaleX / chara.naturalWidth);
						imgStartY = imgStartY + (oldScaleY - imgScaleY) / 2;
					}
				}
				const PADDING = 10;
				if(obj.state & TEXT_STATE.IMAGE_CENTERX) {
					imgStartX += PADDING;
					imgScaleX -= PADDING * 2;
				}
				if(obj.state & TEXT_STATE.IMAGE_CENTERY) {
					imgStartY += PADDING;
					imgScaleY -= PADDING * 2;
				}
				window.ctx.drawImage(chara, imgStartX, imgStartY, imgScaleX, imgScaleY);
				func();
				
			}
		}
		function ctxDrawBG(obj) {
			if((obj.state & TEXT_STATE.BG_DISABLE) == false) {
	 			// テキスト背景描画
				window.ctx.beginPath();
				if(obj.state & TEXT_STATE.BG_KADOMARU) {
					createRoundRectPath(window.ctx, obj.centerX - obj.scaleX / 2, obj.centerY - obj.scaleY / 2, obj.scaleX, obj.scaleY, obj.kadomaruSize)
				} else {
					window.ctx.rect(obj.centerX - obj.scaleX / 2, obj.centerY - obj.scaleY / 2, obj.scaleX, obj.scaleY)
				}
				if(typeof obj.bgColor === 'object') {
					let bgColor = obj.state & TEXT_STATE.HOVER ? obj.bgColor.HOVER : obj.bgColor.NORMAL;
					bgColor = obj.state & TEXT_STATE.ACTIVE ? bgColor : obj.bgColor.DISABLE;
					bgColor = obj.state & TEXT_STATE.HILIGHT ? obj.bgColor.HILIGHT: bgColor;
					window.ctx.fillStyle = bgColor;
				} else {
					window.ctx.fillStyle = obj.bgColor;
				}
				window.ctx.fill();
				// エッジ描画
				if((obj.state & TEXT_STATE.BG_NO_BORDER) == false) {
					window.ctx.strokeStyle = "rgba(0, 0, 255, 0.5)";
					window.ctx.stroke();
					window.ctx.closePath();
				}
			}
		}
		function ctxDrawText(obj) {
			if(!obj.text)
				return;
			let TEXT_MARGIN = 10;
			let LINE_HEIGHT = 10;
			if(obj.margin)
				TEXT_MARGIN = obj.margin;
			if(obj.lineHeight)
				LINE_HEIGHT = obj.lineHeight;
			// \nを区切り文字として分割
			if(obj.state & TEXT_STATE.IS_TEXT) {
				let font = "";
				font += obj.bold ? "bold " : "";
				font += obj.fontSize + "px ";
				font += obj.font ? obj.font + " " : FONT_DEFAULT;
				window.ctx.font = font;
				const measure = window.ctx.measureText(obj.text);
				const textHeight= measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent;
				const texts = obj.text.split("\\n");
				for(let i = 0; i < texts.length; i++) {
		 			var textPosX = obj.centerX - obj.scaleX / 2 + TEXT_MARGIN;
		 			var textPosY = obj.centerY - obj.scaleY / 2 + textHeight + TEXT_MARGIN;
		 			if(obj.state & TEXT_STATE.CENTERX) {
						let textWidth = window.ctx.measureText(texts[i]).width;
		 				textPosX = obj.centerX - textWidth / 2;
		 			}
		 			if(obj.state & TEXT_STATE.CENTERY) {
		 				textPosY = obj.centerY - textHeight * texts.length / 2 + textHeight * (i + 1);
		 				textPosY += -LINE_HEIGHT * (texts.length - 1) / 2 + LINE_HEIGHT * i
		 			} else {
		 				textPosY += (textHeight + LINE_HEIGHT) * i;
					 }
					window.ctx.fillStyle = obj.textColor;
					window.ctx.fillText(texts[i], textPosX, textPosY);
					//window.ctx.strokeStyle = '#000000';
					//window.ctx.lineWidth = 1.5;
					//window.ctx.strokeText(texts[i], textPosX, textPosY);
				}
			}
		}
    </script>
  </body>
</html>